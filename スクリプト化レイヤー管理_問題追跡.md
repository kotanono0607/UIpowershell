# スクリプト化とレイヤー管理 - 問題追跡ドキュメント

**作成日**: 2025-11-01
**管理者**: Claude AI
**目的**: スクリプト化ノードとレイヤー管理の問題を体系的に追跡・解決する

---

## 📊 問題サマリー

| ID | 問題内容 | 深刻度 | ステータス | 修正予定 |
|----|---------|--------|-----------|---------|
| #1 | 右矢印でスクリプト展開状態が失われる | 🔴 重大 | ✅ 完了 | - |
| #2 | Pink選択配列の状態管理の不整合 | 🔴 重大 | ✅ 完了 | - |
| #3 | 階層パス表示の「[不明]」 | 🟡 中 | ✅ 完了 | - |
| #4 | レイヤー移動の設計上の矛盾 | 🟠 設計 | 💡 検討中 | フェーズ3 |
| #5 | レイヤー階層の深さ管理の不整合 | 🟡 中 | 📋 計画中 | フェーズ3 |
| #6 | 左矢印バリデーションの不完全性 | 🟢 低 | ✅ 完了 | - |
| #7 | 矢印削除時のpictureBoxエラー | 🟡 中 | 🔍 調査中 | 調査中 |

---

## ✅ フェーズ1+2 完了サマリー

**完了日**: 2025-11-01
**テスト実施**: ユーザー
**修正内容**: スクリプト化とレイヤー管理の同期問題を解決

### 完了した問題
- ✅ **問題#1**: 右矢印でスクリプト展開状態が失われる → **解決**
- ✅ **問題#2**: Pink選択配列の状態管理の不整合 → **解決**
- ✅ **問題#3**: 階層パス表示の「[不明]」 → **解決**
- ✅ **問題#6**: 左矢印バリデーションの不完全性 → **解決**（#1,2の修正により自動解決）

### 修正ファイル
1. `06_メインフォームUI_フレーム移動.ps1` - Pink選択配列リセット処理を追加
2. `02_メインフォームUI_foam関数.ps1` - 階層パス表示のレイヤー0→1遷移を特別扱い

### テスト結果
```
✅ Pink選択配列リセット: 正常動作確認
✅ レイヤー状態の整合性: 正常動作確認
✅ バリデーションエラー表示: 正常動作確認
✅ 階層パス表示: 「[不明]」が消えた
```

### 次のステップ
- 問題#7（pictureBoxエラー）の調査・修正
- 問題#4,5（設計改善）はユーザーの要望に応じてフェーズ3で検討

---

## 🔴 問題 #1: 右矢印でスクリプト展開状態が失われる

### 現象
```
1. レイヤー1でスクリプト化ノード（例: 112-1）を展開 → レイヤー2にノードを作成
2. 左矢印を押す → レイヤー2に進む（正常）
3. 右矢印を押してレイヤー1に戻る
   結果: レイヤー2の内容が削除される（問題）
4. 再度左矢印を押す
   結果: レイヤー2は空になっている（データ損失）
```

### 原因
**ファイル**: `06_メインフォームUI_フレーム移動.ps1`
**関数**: `メインフレームの右を押した場合の処理` (行70-85)

```powershell
# 現在のレイヤーより深いレイヤーをすべてクリア
for ($i = [int]$現在のレイヤー番号 + 1; $i -le 6; $i++) {
    フレームパネルからすべてのボタンを削除する -フレームパネル $クリア対象パネル
}
# ← Pink選択配列をリセットする処理が存在しない
```

### 影響
- ✗ 「レイヤー1→レイヤー2→レイヤー1（確認）→レイヤー2（再度確認）」という往復操作ができない
- ✗ 展開したノードが戻るたびに消える
- ✗ ユーザーが作業内容を失う

### 修正方針
レイヤーをクリアする際、対応するPink選択配列も同期してリセットする

```powershell
# 修正後のコード（イメージ）
for ($i = [int]$現在のレイヤー番号 + 1; $i -le 6; $i++) {
    # レイヤーパネルをクリア
    フレームパネルからすべてのボタンを削除する -フレームパネル $クリア対象パネル

    # ★ 追加: Pink選択配列もリセット
    if ($i -ge 1 -and $i -le 6) {
        $Global:Pink選択配列[$i - 1].値 = 0
        $Global:Pink選択配列[$i - 1].展開ボタン = 0
        $Global:Pink選択配列[$i - 1].Y座標 = 0
    }
}
```

### テストケース（問題#1）
```
【テスト1-1】右矢印でレイヤークリア後、Pink選択配列がリセットされるか
1. レイヤー1でスクリプト化ノードを作成
2. スクリプト化ノードをクリックしてレイヤー2を展開
3. 右矢印でレイヤー1に戻る
   期待結果: レイヤー2の内容が削除され、Pink選択配列[1].値=0になる

【テスト1-2】右矢印後に左矢印を押すと正しくバリデーションされるか
1. テスト1-1の続き
2. 左矢印を押す
   期待結果: 「スクリプト展開が必要です」というエラーメッセージが表示される
```

### 修正ステータス
- [x] 原因特定完了
- [x] コード修正完了（2025-11-01）
- [x] テスト完了（2025-11-01、ユーザー実施）
- [x] 本番適用完了

**テスト結果**（2025-11-01）:
```
右矢印: 現在のレイヤー 1 より深いレイヤーをクリアします
  レイヤー2 をクリア
    → Pink選択配列[1] をリセット  ✅ 正常動作
  ...
[❌ 左矢印] レイヤー1 でスクリプト展開中ではないため、進めません  ✅ 正常動作
```

---

## 🔴 問題 #2: Pink選択配列の状態管理の不整合

### 現象
```
スクリプト展開時:
  Pink選択配列[$親レイヤー番号].値 = 1
  Pink選択配列[$親レイヤー番号].展開ボタン = "112-1"

右矢印でレイヤーをクリア後:
  レイヤー2のノードは削除される（OK）
  Pink選択配列の状態はそのまま（NG）

結果: レイヤーの実際の状態とPink選択配列が不整合
```

### 原因
**問題#1と同根**

1. **スクリプト展開時の更新** (02_メインフォームUI_foam関数.ps1:1385-1388):
   ```powershell
   $Global:Pink選択配列[$A].Y座標 = $sender.Location.Y +15
   $Global:Pink選択配列[$A].値 = 1
   $Global:Pink選択配列[$A].展開ボタン = $sender.Name
   ```

2. **レイヤークリア時の未更新** (06_メインフォームUI_フレーム移動.ps1):
   - Pink選択配列をリセットする処理が存在しない

### 影響
- Pink選択配列がレイヤーの実際の状態を反映しない
- 左矢印のバリデーション（スクリプト展開チェック）が誤動作する可能性
- 階層パス表示が不正確になる

### 修正方針
**問題#1と同時に修正**

### テストケース（問題#2）
```
【テスト2-1】Pink選択配列とレイヤー状態の整合性確認
1. レイヤー1でスクリプト化ノードをクリック
   確認: Pink選択配列[1].値 = 1, 展開ボタン = "ノード名"
2. レイヤー2にノードが作成される
3. 右矢印でレイヤー1に戻る
   確認: Pink選択配列[1].値 = 0, 展開ボタン = 0
4. レイヤー2の内容が空
   確認: レイヤー2にボタンが0個
```

### 修正ステータス
- [x] 原因特定完了
- [x] コード修正完了（2025-11-01）
- [x] テスト完了（2025-11-01、ユーザー実施）
- [x] 本番適用完了

**テスト結果**（2025-11-01）:
```
右矢印: 現在のレイヤー 1 より深いレイヤーをクリアします
  レイヤー2 をクリア
    → Pink選択配列[1] をリセット  ✅ 正常動作

Pink選択配列とレイヤー状態の整合性が保たれている  ✅ 正常動作
```

---

## 🟡 問題 #3: 階層パス表示の「[不明]」

### 現象
```
階層パス表示:
📍 階層パス: レイヤー0 → [不明] → レイヤー1
```

### 原因
**ファイル**: `02_メインフォームUI_foam関数.ps1:2593-2596`

```powershell
if ($展開ボタン -and $展開ボタン -ne 0) {
    $パス部分 += "→ $展開ボタン"
    $パス部分 += "→ レイヤー$($i + 1)"
} else {
    $パス部分 += "→ [不明]"  # ← ここで「不明」と表示
    $パス部分 += "→ レイヤー$($i + 1)"
}
```

### 根本原因
- レイヤー0からレイヤー1への遷移は、スクリプト展開を経由していない（初期状態）
- Pink選択配列[0]が初期化されていないため、`展開ボタン = 0`

### 修正方針（案1）
レイヤー0→レイヤー1の遷移を特別扱いする

```powershell
for ($i = 0; $i -lt $現在のレイヤー番号; $i++) {
    $展開ボタン = $Global:Pink選択配列[$i].展開ボタン

    if ($i -eq 0) {
        # レイヤー0→レイヤー1は常に「直接遷移」
        $パス部分 += "→ レイヤー1"
    } elseif ($展開ボタン -and $展開ボタン -ne 0) {
        $パス部分 += "→ $展開ボタン"
        $パス部分 += "→ レイヤー$($i + 1)"
    } else {
        $パス部分 += "→ [不明]"
        $パス部分 += "→ レイヤー$($i + 1)"
    }
}
```

### 修正方針（案2）
「[不明]」を「(初期レイヤー)」に変更

```powershell
} else {
    $パス部分 += "→ (初期レイヤー)"
    $パス部分 += "→ レイヤー$($i + 1)"
}
```

### テストケース（問題#3）
```
【テスト3-1】初期状態の階層パス表示
1. アプリケーションを起動
   期待結果: 📍 階層パス: レイヤー0 → レイヤー1

【テスト3-2】スクリプト展開後の階層パス表示
1. レイヤー1でスクリプト化ノードをクリック
2. レイヤー2を表示
   期待結果: 📍 階層パス: レイヤー0 → レイヤー1 → 112-1 → レイヤー2
```

### 修正ステータス
- [x] 原因特定完了
- [x] 修正方針確定（案1を採用）
- [x] コード修正完了（2025-11-01）
- [x] テスト完了（2025-11-01、ユーザー実施）
- [x] 本番適用完了

**採用した修正方針**: 案1（レイヤー0→レイヤー1を特別扱い）

**テスト結果**（2025-11-01）:
```
[階層パス] レイヤー0 → レイヤー1  ✅ 正常動作（「[不明]」が消えた）
```

---

## 🟠 問題 #4: レイヤー移動の設計上の矛盾

### 現象
```
現在の仕様:
- 左矢印（進む）: 現在のレイヤー番号より深いレイヤーをクリア
- 右矢印（戻る）: 現在のレイヤー番号より深いレイヤーをクリア

結果:
- どちらの矢印を押しても深いレイヤーがクリアされる
- 「戻って再度進む」という操作ができない
```

### 影響
- ユーザーが自由にレイヤー間を行き来できない
- 確認のために戻ると、展開した内容が失われる

### 理想的な仕様（検討中）
```
1. スクリプト展開状態を保持したまま、レイヤー間を自由に行き来できる
2. レイヤーをクリアするのは、以下の場合のみ:
   - ユーザーが明示的に「閉じる」操作をした場合
   - 新しいスクリプトを展開して既存の展開を上書きする場合
   - ワークフローを切り替える場合
```

### 設計案（未確定）
- **案A**: レイヤー移動時はクリアせず、表示の切り替えのみ行う
- **案B**: 「閉じる」ボタンを追加し、明示的な操作でのみクリア
- **案C**: 現在の仕様を維持し、問題#1,2を修正するのみ

### 修正ステータス
- [x] 問題認識完了
- [ ] 設計案確定
- [ ] ユーザーとの仕様合意
- [ ] コード修正完了
- [ ] テスト完了

---

## 🟡 問題 #5: レイヤー階層の深さ管理の不整合

### 現象
```
$Global:レイヤー階層の深さ の意味が不明確:
- 「現在表示中のレイヤー番号」を表すのか？
- 「実際に展開されている最深レイヤー番号」を表すのか？
```

### 影響
- 変数の意味が不明確で、バグの温床になる
- レイヤー移動のたびに巻き戻されるため、スクリプト展開の履歴が失われる

### 修正方針
変数名と役割を明確化する
- `$Global:現在表示中のレイヤー番号`: 現在表示しているレイヤー
- `$Global:最深展開レイヤー番号`: 実際に展開されている最深レイヤー

### 修正ステータス
- [x] 問題認識完了
- [ ] 設計案確定
- [ ] コード修正完了
- [ ] テスト完了

---

## 🟢 問題 #6: 左矢印バリデーションの不完全性

### 現象
左矢印のバリデーション（スクリプト展開チェック）が、Pink選択配列の状態のみに依存している

```powershell
if ($Global:Pink選択配列[$現在のレイヤー番号].値 -ne 1) {
    # エラーメッセージを表示
    return
}
```

### 影響
- **問題#2**が発生している場合、このバリデーションが誤動作する
- レイヤーがクリアされてもPink選択配列が値=1のままの場合、バリデーションを通過してしまう

### 修正方針
**問題#1,2の修正により自動的に解決される**

### 修正ステータス
- [x] 問題認識完了
- [x] 問題#1,2の修正完了（2025-11-01）
- [x] 修正後の動作確認完了（2025-11-01）

**結果**: 問題#1,2の修正により、このバリデーション問題も自動的に解決された

**テスト結果**（2025-11-01）:
```
[❌ 左矢印] レイヤー1 でスクリプト展開中ではないため、進めません  ✅ 正常動作
```

---

## 📋 修正フェーズ

### **フェーズ1: 緊急修正（優先度：最高）**
**対象**: 問題#1, #2
**目標**: レイヤークリア時にPink選択配列も同期してリセット
**期限**: 即時
**修正ファイル**:
- `06_メインフォームUI_フレーム移動.ps1` (2箇所)

**作業内容**:
1. `メインフレームの左を押した場合の処理` (行26-41) にPink選択配列リセット処理を追加
2. `メインフレームの右を押した場合の処理` (行70-85) にPink選択配列リセット処理を追加
3. テストケース1-1, 1-2, 2-1を実行

---

### **フェーズ2: UI改善（優先度：高）**
**対象**: 問題#3
**目標**: 階層パス表示の「[不明]」を修正
**期限**: フェーズ1完了後
**修正ファイル**:
- `02_メインフォームUI_foam関数.ps1` (階層パス表示関数)

**作業内容**:
1. レイヤー0→レイヤー1の遷移を特別扱いする
2. テストケース3-1, 3-2を実行

---

### **フェーズ3: 設計改善（優先度：中、オプション）**
**対象**: 問題#4, #5
**目標**: より柔軟なレイヤー管理
**期限**: ユーザーとの仕様合意後

**検討事項**:
- レイヤー移動時にクリアしない仕様への変更
- 明示的な「閉じる」操作の追加
- 変数名の明確化

---

## 📝 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2025-11-01 | 1.0 | 初版作成、問題#1〜#6を記録 |
| 2025-11-01 | 1.1 | フェーズ1+2修正完了、問題#1,2,3,6のテスト結果を記録 |
| 2025-11-01 | 1.2 | 問題#7（pictureBoxエラー）を追加 |

---

## 🔗 関連ドキュメント

- **仕様書.md**: システム全体の仕様
- **SPEC.md**: 詳細仕様
- **issue_list.txt**: 今後の開発予定

---

**このドキュメントは継続的に更新されます。**
